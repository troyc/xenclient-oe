Index: tboot-1.9.12/tboot/common/cmdline.c
===================================================================
--- tboot-1.9.12.orig/tboot/common/cmdline.c
+++ tboot-1.9.12/tboot/common/cmdline.c
@@ -307,10 +307,12 @@ static bool parse_pci_bdf(const char **b
 bool g_psbdf_enabled = false;
 static bool parse_com_psbdf(const char **bdf)
 {
-    g_psbdf_enabled = parse_pci_bdf(bdf,
-                  &g_com_port.comc_psbdf.bus,
-                  &g_com_port.comc_psbdf.slot,
-                  &g_com_port.comc_psbdf.func);
+    uint32_t b, d, f;
+
+    g_psbdf_enabled = parse_pci_bdf(bdf, &b, &d, &f);
+    g_com_port.comc_psbdf.bus = b;
+    g_com_port.comc_psbdf.slot = d;
+    g_com_port.comc_psbdf.func = f;
 
     return g_psbdf_enabled;
 }
@@ -318,10 +320,12 @@ static bool parse_com_psbdf(const char *
 bool g_pbbdf_enabled = false;
 static bool parse_com_pbbdf(const char **bdf)
 {
-    g_pbbdf_enabled = parse_pci_bdf(bdf,
-                  &g_com_port.comc_pbbdf.bus,
-                  &g_com_port.comc_pbbdf.slot,
-                  &g_com_port.comc_pbbdf.func);
+    uint32_t b, d, f;
+
+    g_pbbdf_enabled = parse_pci_bdf(bdf, &b, &d, &f);
+    g_com_port.comc_pbbdf.bus = b;
+    g_com_port.comc_pbbdf.slot = d;
+    g_com_port.comc_pbbdf.func = f;
 
     return g_pbbdf_enabled;
 }
Index: tboot-1.9.12/tboot/common/acpi.c
===================================================================
--- tboot-1.9.12.orig/tboot/common/acpi.c
+++ tboot-1.9.12/tboot/common/acpi.c
@@ -181,12 +181,11 @@ static struct acpi_table_header *find_ta
     struct acpi_table_header *table = NULL;
     struct acpi_xsdt *xsdt = get_xsdt(); /* it is ok even on 1.0 tables */
                                          /* because value will be ignored */
+    unsigned int i;
 
     if ( rsdp->rsdp1.revision >= 2 && xsdt != NULL ) { /*  ACPI 2.0+ */
-        for ( uint64_t *curr_table = xsdt->table_offsets;
-              curr_table < (uint64_t *)((void *)xsdt + xsdt->hdr.length);
-              curr_table++ ) {
-            table = (struct acpi_table_header *)(uintptr_t)*curr_table;
+        for ( i = 0; i < xsdt->hdr.length; ++i ) {
+            table = (void*)(uintptr_t)xsdt->table_offsets[i];
             if ( tb_memcmp(table->signature, table_name,
                         sizeof(table->signature)) == 0 )
                 return table;
@@ -200,10 +199,8 @@ static struct acpi_table_header *find_ta
             return NULL;
         }
 
-        for ( uint32_t *curr_table = rsdt->table_offsets;
-              curr_table < (uint32_t *)((void *)rsdt + rsdt->hdr.length);
-              curr_table++ ) {
-            table = (struct acpi_table_header *)(uintptr_t)*curr_table;
+        for ( i = 0; i < rsdt->hdr.length; ++i ) {
+            table = (void*)(uintptr_t)xsdt->table_offsets[i];
             if ( tb_memcmp(table->signature, table_name,
                         sizeof(table->signature)) == 0 )
                 return table;
Index: tboot-1.9.12/tboot/common/tboot.c
===================================================================
--- tboot-1.9.12.orig/tboot/common/tboot.c
+++ tboot-1.9.12/tboot/common/tboot.c
@@ -383,13 +383,19 @@ void begin_launch(void *addr, uint32_t m
     }
     printk(TBOOT_INFO"BSP is cpu %u\n", get_apicid());
 
+    printk(TBOOT_ERR"AXA hi\n");
+    printk(TBOOT_ERR"AXA type is %016Lx\n", (unsigned long long)g_ldr_ctx->type);
     /* make copy of e820 map that we will use and adjust */
     if ( !s3_flag ) {
-        if ( !copy_e820_map(g_ldr_ctx) )  apply_policy(TB_ERR_FATAL);
-        if (efi_memmap_copy(g_ldr_ctx)) {
+        if ( !copy_e820_map(g_ldr_ctx) )  {
+	    printk(TBOOT_ERR"AXA copy_e820_map returned false\n");
+	    apply_policy(TB_ERR_FATAL);
+	}
+        if (g_ldr_ctx->type == 2 && efi_memmap_copy(g_ldr_ctx)) {
             printk(TBOOT_INFO"Original EFI memory map:\n");
             efi_memmap_dump();
         }
+        printk(TBOOT_INFO"AXA hi 2\n");
     }
 
     /* we need to make sure this is a (TXT-) capable platform before using */
@@ -397,7 +403,9 @@ void begin_launch(void *addr, uint32_t m
     /* has already been launched */
 
     if (g_sinit == NULL) {
+       printk(TBOOT_INFO"AXA hi 3\n");
        find_platform_sinit_module(g_ldr_ctx, (void **)&g_sinit, NULL);
+       printk(TBOOT_INFO"AXA hi 4\n");
        /* check if it is newer than BIOS provided version, then copy it to BIOS reserved region */
        g_sinit = copy_sinit(g_sinit); 
        if (g_sinit == NULL) 
@@ -406,6 +414,7 @@ void begin_launch(void *addr, uint32_t m
            apply_policy(TB_ERR_ACMOD_VERIFY_FAILED);
     }
     
+       printk(TBOOT_INFO"AXA hi 5\n");
     /* make TPM ready for measured launch */
     if (!tpm_detect())
        apply_policy(TB_ERR_TPM_NOT_READY);
@@ -573,7 +582,9 @@ void shutdown(void)
 {
     struct tpm_if *tpm = get_tpm();
     const struct tpm_if_fp *tpm_fp = get_tpm_fp();
-   
+    uint32_t *num_in_wfs =
+        __builtin_assume_aligned(&_tboot_shared.num_in_wfs, 4);
+
     /* wait-for-sipi only invoked for APs, so skip all BSP shutdown code */
     if ( _tboot_shared.shutdown_type == TB_SHUTDOWN_WFS ) {
         atomic_inc(&ap_wfs_count);
@@ -588,7 +599,7 @@ void shutdown(void)
     }
 
     printk(TBOOT_INFO"wait until all APs ready for txt shutdown\n");
-    while( atomic_read(&_tboot_shared.num_in_wfs)
+    while( atomic_read(num_in_wfs)
            < atomic_read(&ap_wfs_count) )
         cpu_relax();
 
Index: tboot-1.9.12/tboot/txt/verify.c
===================================================================
--- tboot-1.9.12.orig/tboot/txt/verify.c
+++ tboot-1.9.12/tboot/txt/verify.c
@@ -408,9 +408,11 @@ tb_error_t txt_verify_platform(void)
 static bool verify_saved_mtrrs(txt_heap_t *txt_heap)
 {
     os_mle_data_t *os_mle_data;
+    mtrr_state_t saved_mtrr_state;
     os_mle_data = get_os_mle_data_start(txt_heap);
+    saved_mtrr_state = os_mle_data->saved_mtrr_state;
 
-    return validate_mtrrs(&(os_mle_data->saved_mtrr_state));
+    return validate_mtrrs(&(saved_mtrr_state));
 }
 
 tb_error_t txt_post_launch_verify_platform(void)
Index: tboot-1.9.12/lcptools/readpol.c
===================================================================
--- tboot-1.9.12.orig/lcptools/readpol.c
+++ tboot-1.9.12/lcptools/readpol.c
@@ -147,6 +147,8 @@ static void print_policy(unsigned char*
                                       "LCP_POLTYPE_UNSIGNED",
                                       "LCP_POLTYPE_SIGNED", "LCP_POLTYPE_ANY",
                                       "LCP_POLTYPE_FORCEOWNERPOLICY"};
+    uint32_t policy_control;
+    uint16_t res;
 
     if ( buf_len < (offsetof(lcp_policy_t, policy_hash) +
                     sizeof(pol.policy_hash.sha1) + 1) ) {
@@ -157,10 +159,11 @@ static void print_policy(unsigned char*
     lcp_unloaddata_byte(&pol.hash_alg, &pdata);
     lcp_unloaddata_byte(&pol.policy_type, &pdata);
     lcp_unloaddata_byte(&pol.sinit_revocation_counter, &pdata);
-    lcp_unloaddata_uint32(&pol.policy_control, &pdata, 1);
-    lcp_unloaddata_uint16(&pol.reserved[0], &pdata, 1);
-    lcp_unloaddata_uint16(&pol.reserved[1], &pdata, 1);
-    lcp_unloaddata_uint16(&pol.reserved[2], &pdata, 1);
+    lcp_unloaddata_uint32(&policy_control, &pdata, 1);
+    pol.policy_control = policy_control;
+    lcp_unloaddata_uint16(&res, &pdata, 1); pol.reserved[0] = res;
+    lcp_unloaddata_uint16(&res, &pdata, 1); pol.reserved[1] = res;
+    lcp_unloaddata_uint16(&res, &pdata, 1); pol.reserved[2] = res;
     lcp_unloaddata(sizeof(pol.policy_hash.sha1), &pdata,
 		   (unsigned char *)&pol.policy_hash);
 
Index: tboot-1.9.12/safestringlib/safeclib/mem_primitives_lib.c
===================================================================
--- tboot-1.9.12.orig/safestringlib/safeclib/mem_primitives_lib.c
+++ tboot-1.9.12/safestringlib/safeclib/mem_primitives_lib.c
@@ -108,21 +108,21 @@ mem_prim_set (void *dest, uint32_t len,
             lcount -= 16;
             break;
 
-        case 15:  *lp++ = value32;
-        case 14:  *lp++ = value32;
-        case 13:  *lp++ = value32;
-        case 12:  *lp++ = value32;
-        case 11:  *lp++ = value32;
-        case 10:  *lp++ = value32;
-        case 9:  *lp++ = value32;
-        case 8:  *lp++ = value32;
-
-        case 7:  *lp++ = value32;
-        case 6:  *lp++ = value32;
-        case 5:  *lp++ = value32;
-        case 4:  *lp++ = value32;
-        case 3:  *lp++ = value32;
-        case 2:  *lp++ = value32;
+        case 15:  *lp++ = value32; __attribute__ ((fallthrough));
+        case 14:  *lp++ = value32; __attribute__ ((fallthrough));
+        case 13:  *lp++ = value32; __attribute__ ((fallthrough));
+        case 12:  *lp++ = value32; __attribute__ ((fallthrough));
+        case 11:  *lp++ = value32; __attribute__ ((fallthrough));
+        case 10:  *lp++ = value32; __attribute__ ((fallthrough));
+        case 9:  *lp++ = value32; __attribute__ ((fallthrough));
+        case 8:  *lp++ = value32; __attribute__ ((fallthrough));
+
+        case 7:  *lp++ = value32; __attribute__ ((fallthrough));
+        case 6:  *lp++ = value32; __attribute__ ((fallthrough));
+        case 5:  *lp++ = value32; __attribute__ ((fallthrough));
+        case 4:  *lp++ = value32; __attribute__ ((fallthrough));
+        case 3:  *lp++ = value32; __attribute__ ((fallthrough));
+        case 2:  *lp++ = value32; __attribute__ ((fallthrough));
         case 1:  *lp++ = value32;
             lcount = 0;
             break;
@@ -194,21 +194,21 @@ mem_prim_set16 (uint16_t *dp, uint32_t l
             len -= 16;
             break;
 
-        case 15:  *dp++ = value;
-        case 14:  *dp++ = value;
-        case 13:  *dp++ = value;
-        case 12:  *dp++ = value;
-        case 11:  *dp++ = value;
-        case 10:  *dp++ = value;
-        case 9:  *dp++ = value;
-        case 8:  *dp++ = value;
-
-        case 7:  *dp++ = value;
-        case 6:  *dp++ = value;
-        case 5:  *dp++ = value;
-        case 4:  *dp++ = value;
-        case 3:  *dp++ = value;
-        case 2:  *dp++ = value;
+        case 15:  *dp++ = value; __attribute__ ((fallthrough));
+        case 14:  *dp++ = value; __attribute__ ((fallthrough));
+        case 13:  *dp++ = value; __attribute__ ((fallthrough));
+        case 12:  *dp++ = value; __attribute__ ((fallthrough));
+        case 11:  *dp++ = value; __attribute__ ((fallthrough));
+        case 10:  *dp++ = value; __attribute__ ((fallthrough));
+        case 9:  *dp++ = value; __attribute__ ((fallthrough));
+        case 8:  *dp++ = value; __attribute__ ((fallthrough));
+
+        case 7:  *dp++ = value; __attribute__ ((fallthrough));
+        case 6:  *dp++ = value; __attribute__ ((fallthrough));
+        case 5:  *dp++ = value; __attribute__ ((fallthrough));
+        case 4:  *dp++ = value; __attribute__ ((fallthrough));
+        case 3:  *dp++ = value; __attribute__ ((fallthrough));
+        case 2:  *dp++ = value; __attribute__ ((fallthrough));
         case 1:  *dp++ = value;
             len = 0;
             break;
@@ -265,21 +265,21 @@ mem_prim_set32 (uint32_t *dp, uint32_t l
             len -= 16;
             break;
 
-        case 15:  *dp++ = value;
-        case 14:  *dp++ = value;
-        case 13:  *dp++ = value;
-        case 12:  *dp++ = value;
-        case 11:  *dp++ = value;
-        case 10:  *dp++ = value;
-        case 9:  *dp++ = value;
-        case 8:  *dp++ = value;
-
-        case 7:  *dp++ = value;
-        case 6:  *dp++ = value;
-        case 5:  *dp++ = value;
-        case 4:  *dp++ = value;
-        case 3:  *dp++ = value;
-        case 2:  *dp++ = value;
+        case 15:  *dp++ = value; __attribute__ ((fallthrough));
+        case 14:  *dp++ = value; __attribute__ ((fallthrough));
+        case 13:  *dp++ = value; __attribute__ ((fallthrough));
+        case 12:  *dp++ = value; __attribute__ ((fallthrough));
+        case 11:  *dp++ = value; __attribute__ ((fallthrough));
+        case 10:  *dp++ = value; __attribute__ ((fallthrough));
+        case 9:  *dp++ = value; __attribute__ ((fallthrough));
+        case 8:  *dp++ = value; __attribute__ ((fallthrough));
+
+        case 7:  *dp++ = value; __attribute__ ((fallthrough));
+        case 6:  *dp++ = value; __attribute__ ((fallthrough));
+        case 5:  *dp++ = value; __attribute__ ((fallthrough));
+        case 4:  *dp++ = value; __attribute__ ((fallthrough));
+        case 3:  *dp++ = value; __attribute__ ((fallthrough));
+        case 2:  *dp++ = value; __attribute__ ((fallthrough));
         case 1:  *dp++ = value;
             len = 0;
             break;
@@ -518,21 +518,21 @@ mem_prim_move8 (uint8_t *dp, const uint8
                   len -= 16;
                   break;
 
-             case 15:  *dp++ = *sp++;
-             case 14:  *dp++ = *sp++;
-             case 13:  *dp++ = *sp++;
-             case 12:  *dp++ = *sp++;
-             case 11:  *dp++ = *sp++;
-             case 10:  *dp++ = *sp++;
-             case 9:  *dp++ = *sp++;
-             case 8:  *dp++ = *sp++;
-
-             case 7:  *dp++ = *sp++;
-             case 6:  *dp++ = *sp++;
-             case 5:  *dp++ = *sp++;
-             case 4:  *dp++ = *sp++;
-             case 3:  *dp++ = *sp++;
-             case 2:  *dp++ = *sp++;
+             case 15:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 14:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 13:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 12:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 11:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 10:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 9:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 8:  *dp++ = *sp++; __attribute__ ((fallthrough));
+
+             case 7:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 6:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 5:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 4:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 3:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 2:  *dp++ = *sp++; __attribute__ ((fallthrough));
              case 1:  *dp++ = *sp++;
                  len = 0;
                  break;
@@ -568,21 +568,21 @@ mem_prim_move8 (uint8_t *dp, const uint8
                  len -= 16;
                  break;
 
-            case 15:  *--dp = *--sp;
-            case 14:  *--dp = *--sp;
-            case 13:  *--dp = *--sp;
-            case 12:  *--dp = *--sp;
-            case 11:  *--dp = *--sp;
-            case 10:  *--dp = *--sp;
-            case 9:  *--dp = *--sp;
-            case 8:  *--dp = *--sp;
-
-            case 7:  *--dp = *--sp;
-            case 6:  *--dp = *--sp;
-            case 5:  *--dp = *--sp;
-            case 4:  *--dp = *--sp;
-            case 3:  *--dp = *--sp;
-            case 2:  *--dp = *--sp;
+            case 15:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 14:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 13:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 12:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 11:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 10:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 9:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 8:  *--dp = *--sp; __attribute__ ((fallthrough));
+
+            case 7:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 6:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 5:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 4:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 3:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 2:  *--dp = *--sp; __attribute__ ((fallthrough));
             case 1:  *--dp = *--sp;
                 len = 0;
                 break;
@@ -649,21 +649,21 @@ mem_prim_move16 (uint16_t *dp, const uin
                   len -= 16;
                   break;
 
-             case 15:  *dp++ = *sp++;
-             case 14:  *dp++ = *sp++;
-             case 13:  *dp++ = *sp++;
-             case 12:  *dp++ = *sp++;
-             case 11:  *dp++ = *sp++;
-             case 10:  *dp++ = *sp++;
-             case 9:  *dp++ = *sp++;
-             case 8:  *dp++ = *sp++;
-
-             case 7:  *dp++ = *sp++;
-             case 6:  *dp++ = *sp++;
-             case 5:  *dp++ = *sp++;
-             case 4:  *dp++ = *sp++;
-             case 3:  *dp++ = *sp++;
-             case 2:  *dp++ = *sp++;
+             case 15:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 14:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 13:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 12:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 11:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 10:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 9:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 8:  *dp++ = *sp++; __attribute__ ((fallthrough));
+
+             case 7:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 6:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 5:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 4:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 3:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 2:  *dp++ = *sp++; __attribute__ ((fallthrough));
              case 1:  *dp++ = *sp++;
                  len = 0;
                  break;
@@ -698,21 +698,21 @@ mem_prim_move16 (uint16_t *dp, const uin
                  len -= 16;
                  break;
 
-            case 15:  *--dp = *--sp;
-            case 14:  *--dp = *--sp;
-            case 13:  *--dp = *--sp;
-            case 12:  *--dp = *--sp;
-            case 11:  *--dp = *--sp;
-            case 10:  *--dp = *--sp;
-            case 9:  *--dp = *--sp;
-            case 8:  *--dp = *--sp;
-
-            case 7:  *--dp = *--sp;
-            case 6:  *--dp = *--sp;
-            case 5:  *--dp = *--sp;
-            case 4:  *--dp = *--sp;
-            case 3:  *--dp = *--sp;
-            case 2:  *--dp = *--sp;
+            case 15:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 14:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 13:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 12:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 11:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 10:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 9:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 8:  *--dp = *--sp; __attribute__ ((fallthrough));
+
+            case 7:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 6:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 5:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 4:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 3:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 2:  *--dp = *--sp; __attribute__ ((fallthrough));
             case 1:  *--dp = *--sp;
                 len = 0;
                 break;
@@ -779,21 +779,21 @@ mem_prim_move32 (uint32_t *dp, const uin
                   len -= 16;
                   break;
 
-             case 15:  *dp++ = *sp++;
-             case 14:  *dp++ = *sp++;
-             case 13:  *dp++ = *sp++;
-             case 12:  *dp++ = *sp++;
-             case 11:  *dp++ = *sp++;
-             case 10:  *dp++ = *sp++;
-             case 9:  *dp++ = *sp++;
-             case 8:  *dp++ = *sp++;
-
-             case 7:  *dp++ = *sp++;
-             case 6:  *dp++ = *sp++;
-             case 5:  *dp++ = *sp++;
-             case 4:  *dp++ = *sp++;
-             case 3:  *dp++ = *sp++;
-             case 2:  *dp++ = *sp++;
+             case 15:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 14:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 13:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 12:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 11:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 10:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 9:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 8:  *dp++ = *sp++; __attribute__ ((fallthrough));
+
+             case 7:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 6:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 5:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 4:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 3:  *dp++ = *sp++; __attribute__ ((fallthrough));
+             case 2:  *dp++ = *sp++; __attribute__ ((fallthrough));
              case 1:  *dp++ = *sp++;
                  len = 0;
                  break;
@@ -827,21 +827,21 @@ mem_prim_move32 (uint32_t *dp, const uin
                  len -= 16;
                  break;
 
-            case 15:  *--dp = *--sp;
-            case 14:  *--dp = *--sp;
-            case 13:  *--dp = *--sp;
-            case 12:  *--dp = *--sp;
-            case 11:  *--dp = *--sp;
-            case 10:  *--dp = *--sp;
-            case 9:  *--dp = *--sp;
-            case 8:  *--dp = *--sp;
-
-            case 7:  *--dp = *--sp;
-            case 6:  *--dp = *--sp;
-            case 5:  *--dp = *--sp;
-            case 4:  *--dp = *--sp;
-            case 3:  *--dp = *--sp;
-            case 2:  *--dp = *--sp;
+            case 15:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 14:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 13:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 12:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 11:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 10:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 9:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 8:  *--dp = *--sp; __attribute__ ((fallthrough));
+
+            case 7:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 6:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 5:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 4:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 3:  *--dp = *--sp; __attribute__ ((fallthrough));
+            case 2:  *--dp = *--sp; __attribute__ ((fallthrough));
             case 1:  *--dp = *--sp;
                 len = 0;
                 break;
Index: tboot-1.9.12/tboot/txt/txt.c
===================================================================
--- tboot-1.9.12.orig/tboot/txt/txt.c
+++ tboot-1.9.12/tboot/txt/txt.c
@@ -859,7 +859,9 @@ tb_error_t txt_launch_environment(loader
 
     /* save MTRRs before we alter them for SINIT launch */
     os_mle_data = get_os_mle_data_start(txt_heap);
-    save_mtrrs(&(os_mle_data->saved_mtrr_state));
+    mtrr_state_t saved_mtrr_state = os_mle_data->saved_mtrr_state;
+    save_mtrrs(&saved_mtrr_state);
+    os_mle_data->saved_mtrr_state = saved_mtrr_state;
 
     /* set MTRRs properly for AC module (SINIT); if this fails the MTRRs may
        not be in a good state to continue a launch, so return TB_ERR_FATAL */
@@ -1099,7 +1101,8 @@ void txt_post_launch(void)
     }
 
     /* restore pre-SENTER MTRRs that were overwritten for SINIT launch */
-    restore_mtrrs(&(os_mle_data->saved_mtrr_state));
+    mtrr_state_t saved_mtrr_state = os_mle_data->saved_mtrr_state;
+    restore_mtrrs(&saved_mtrr_state);
 
     /* now, if there was an error, apply policy */
     apply_policy(err);
@@ -1130,8 +1133,10 @@ void ap_wait(unsigned int cpuid)
     misc |= MSR_IA32_MISC_ENABLE_MONITOR_FSM;
     wrmsr(MSR_IA32_MISC_ENABLE, misc);
 
+    uint32_t *num_in_wfs =
+        __builtin_assume_aligned(&_tboot_shared.num_in_wfs, 4);
     /* this is close enough to entering monitor/mwait loop, so inc counter */
-    atomic_inc((atomic_t *)&_tboot_shared.num_in_wfs);
+    atomic_inc((atomic_t *)num_in_wfs);
     mtx_leave(&ap_lock);
 
     printk(TBOOT_INFO"cpu %u mwait'ing\n", cpuid);
@@ -1145,7 +1150,7 @@ void ap_wait(unsigned int cpuid)
 
     uint32_t sipi_vec = (uint32_t)_tboot_shared.ap_wake_addr;
     atomic_dec(&ap_wfs_count);
-    atomic_dec((atomic_t *)&_tboot_shared.num_in_wfs);
+    atomic_dec((atomic_t *)num_in_wfs);
     cpu_wakeup(cpuid, sipi_vec);
 }
 
@@ -1183,7 +1188,8 @@ void txt_cpu_wakeup(void)
     os_mle_data = get_os_mle_data_start(txt_heap);
 
     /* apply (validated) (pre-SENTER) MTRRs from BSP to each AP */
-    restore_mtrrs(&(os_mle_data->saved_mtrr_state));
+    mtrr_state_t saved_mtrr_state = os_mle_data->saved_mtrr_state;
+    restore_mtrrs(&saved_mtrr_state);
 
     /* restore pre-SENTER IA32_MISC_ENABLE_MSR */
     wrmsr(MSR_IA32_MISC_ENABLE, os_mle_data->saved_misc_enable_msr);
Index: tboot-1.9.12/tboot/txt/vmcs.c
===================================================================
--- tboot-1.9.12.orig/tboot/txt/vmcs.c
+++ tboot-1.9.12/tboot/txt/vmcs.c
@@ -441,17 +441,19 @@ static bool vmx_create_vmcs(unsigned int
 static void launch_mini_guest(unsigned int cpuid)
 {
     unsigned long error;
+    uint32_t *num_in_wfs =
+        __builtin_assume_aligned(&_tboot_shared.num_in_wfs, 4);
 
     printk(TBOOT_DETA"launching mini-guest for cpu %u\n", cpuid);
 
     /* this is close enough to entering wait-for-sipi, so inc counter */
-    atomic_inc((atomic_t *)&_tboot_shared.num_in_wfs);
+    atomic_inc((atomic_t *)num_in_wfs);
 
     __vmlaunch();
 
     /* should not reach here */
     atomic_dec(&ap_wfs_count);
-    atomic_dec((atomic_t *)&_tboot_shared.num_in_wfs);
+    atomic_dec((atomic_t *)num_in_wfs);
     error = __vmread(VM_INSTRUCTION_ERROR);
     printk(TBOOT_ERR"vmlaunch failed for cpu %u, error code %lx\n", cpuid, error);
     apply_policy(TB_ERR_FATAL);
@@ -488,6 +490,8 @@ static void print_failed_vmentry_reason(
 void vmx_vmexit_handler(void)
 {
     unsigned int apicid = get_apicid();
+    uint32_t *num_in_wfs =
+        __builtin_assume_aligned(&_tboot_shared.num_in_wfs, 4);
 
     unsigned int exit_reason = __vmread(VM_EXIT_REASON);
     /*printk("vmx_vmexit_handler, cpu= %d,  exit_reason=%x.\n", apicid, exit_reason);*/
@@ -496,7 +500,7 @@ void vmx_vmexit_handler(void)
         print_failed_vmentry_reason(exit_reason);
         stop_vmx(apicid);
         atomic_dec(&ap_wfs_count);
-        atomic_dec((atomic_t *)&_tboot_shared.num_in_wfs);
+        atomic_dec((atomic_t *)num_in_wfs);
         apply_policy(TB_ERR_FATAL);
     }
     else if ( exit_reason == EXIT_REASON_INIT ) {
@@ -514,7 +518,7 @@ void vmx_vmexit_handler(void)
         /*printk("exiting due to SIPI: vector=%x\n", sipi_vec); */
         stop_vmx(apicid);
         atomic_dec(&ap_wfs_count);
-        atomic_dec((atomic_t *)&_tboot_shared.num_in_wfs);
+        atomic_dec((atomic_t *)num_in_wfs);
         cpu_wakeup(apicid, sipi_vec);
 
         /* cpu_wakeup() doesn't return, so we should never get here */
@@ -524,7 +528,7 @@ void vmx_vmexit_handler(void)
     else if ( exit_reason == EXIT_REASON_VMCALL ) {
         stop_vmx(apicid);
         atomic_dec(&ap_wfs_count);
-        atomic_dec((atomic_t *)&_tboot_shared.num_in_wfs);
+        atomic_dec((atomic_t *)num_in_wfs);
         /* spin */
         while ( true )
             __asm__ __volatile__("cli; hlt;");
Index: tboot-1.9.12/tboot/common/e820.c
===================================================================
--- tboot-1.9.12.orig/tboot/common/e820.c
+++ tboot-1.9.12/tboot/common/e820.c
@@ -299,7 +299,9 @@ bool copy_e820_map(loader_ctx *lctx)
         printk(TBOOT_DETA"original e820 map:\n");
         print_map(memmap, memmap_length/sizeof(memory_map_t));
 
+        printk(TBOOT_ERR"AXA bloop 1\n");
         uint32_t entry_offset = 0;
+        printk(TBOOT_ERR"BXB memmap_length %016Lx\n",(unsigned long long)memmap_length);
 
         while ( entry_offset < memmap_length &&
                 g_nr_map < MAX_E820_ENTRIES ) {
@@ -309,10 +311,15 @@ bool copy_e820_map(loader_ctx *lctx)
             /* we want to support unordered and/or overlapping entries */
             /* so use protect_region() to insert into existing map, since */
             /* it handles these cases */
+        printk(TBOOT_ERR"AXA at %016Lx len %016Lx off %016Lx\n", (unsigned long long)e820_base_64(entry), (unsigned long long)e820_length_64(entry), (unsigned long long)entry_offset);
             if ( !protect_region(g_copy_e820_map, &g_nr_map,
                                  e820_base_64(entry), e820_length_64(entry),
                                  entry->type) )
+	    {
+		printk(TBOOT_ERR"AXA failed protect_region\n");
+		printk(TBOOT_ERR"AXA ...at %016Lx len %016Lx\n", (unsigned long long)e820_base_64(entry), (unsigned long long)e820_length_64(entry));
                 return false;
+	    }
             if (lctx->type == 1)
                 entry_offset += entry->size + sizeof(entry->size);
             if (lctx->type == 2)
Index: tboot-1.9.12/tboot/common/efi_memmap.c
===================================================================
--- tboot-1.9.12.orig/tboot/common/efi_memmap.c
+++ tboot-1.9.12/tboot/common/efi_memmap.c
@@ -57,18 +57,22 @@ static bool region_is_free(uint32_t regi
 bool efi_memmap_copy(loader_ctx *lctx)
 {
     uint32_t descr_addr, descr_ver, descr_size, mmap_size;
+    printk(TBOOT_ERR"AXA e1\n");
     descr_addr = find_efi_memmap(lctx, &descr_size,
                                  &descr_ver, &mmap_size);
 
+    printk(TBOOT_ERR"AXA e2\n");
     if (descr_addr == 0 || descr_ver != EFI_MEMORY_DESCRIPTOR_VERSION) {
-        printk(TBOOT_WARN"Failed to get EFI memory map\n");
+        printk(TBOOT_WARN"AXA Failed to get EFI memory map; addr %x ver %x\n", descr_addr, descr_ver);
         return false;
     }
 
+    printk(TBOOT_ERR"AXA e3\n");
     efi_mmap->size = mmap_size;
     efi_mmap->descr_size = descr_size;
     tb_memcpy(efi_mmap->descr, (void*)descr_addr, mmap_size);
     efi_mmap_available = true;
+    printk(TBOOT_ERR"AXA e4\n");
 
     return true;
 }
@@ -352,4 +356,4 @@ static bool region_is_free(uint32_t regi
     } else {
         return false;
     }
-}
\ No newline at end of file
+}
Index: tboot-1.9.12/tboot/common/loader.c
===================================================================
--- tboot-1.9.12.orig/tboot/common/loader.c
+++ tboot-1.9.12/tboot/common/loader.c
@@ -130,6 +130,7 @@ static struct mb2_tag
     void *addr = (void *) start;
     if (start == NULL)
         return NULL;
+    printk(TBOOT_ERR"AXA at tag %016Lx, size %016Lx, addr %p\n", (unsigned long long)start->type,(unsigned long long)start->size, addr);
     if (start->type == MB2_TAG_TYPE_END)
         return NULL;
     addr += ((start->size + 7) & ~7);
@@ -139,11 +140,16 @@ static struct mb2_tag
 static struct mb2_tag 
 *find_mb2_tag_type(struct mb2_tag *start, uint32_t tag_type)
 {
+    printk(TBOOT_ERR"AXA searching for tag %x\n", tag_type);
     while (start != NULL){
         if (start->type == tag_type)
+        {
+            printk(TBOOT_ERR"AXA found tag type %x\n", tag_type); 
             return start;
+        }
         start = next_mb2_tag(start);
     }
+    printk(TBOOT_ERR"AXA did not find tag type %x\n", tag_type);
     return start;
 }
 
@@ -1602,6 +1608,7 @@ char *get_cmdline(loader_ctx *lctx)
 
     if (lctx->type == MB1_ONLY){
         /* multiboot 1 */
+	printk(TBOOT_ERR"AXA mb1\n");
         if (((multiboot_info_t *)lctx->addr)->flags & MBI_CMDLINE){
             return (char *) ((multiboot_info_t *)lctx->addr)->cmdline;
         } else {
@@ -1609,9 +1616,11 @@ char *get_cmdline(loader_ctx *lctx)
         }
     } else { 
         /* currently must be type  2 */
+	printk(TBOOT_ERR"AXA mb2\n");
         struct mb2_tag *start = (struct mb2_tag *)(lctx->addr + 8);
         start = find_mb2_tag_type(start, MB2_TAG_TYPE_CMDLINE);
         if (start != NULL){
+	    printk(TBOOT_ERR"AXA got the cmdline!\n");
             struct mb2_tag_string *cmd = (struct mb2_tag_string *) start;
             return (char *) &(cmd->string);
         }
@@ -2009,8 +2018,10 @@ find_efi_memmap(loader_ctx *lctx, uint32
     struct mb2_tag *start = NULL, *hit = NULL;
     struct mb2_tag_efi_mmap *efi_mmap = NULL;
 
+    printk(TBOOT_ERR"AXA find_efi_memmap 1\n");
     start = (struct mb2_tag *)(lctx->addr + 8);
     hit = find_mb2_tag_type(start, MB2_TAG_TYPE_EFI_MMAP);
+    printk(TBOOT_ERR"AXA find_efi_memmap 2\n");
     if (hit == NULL) {
        return 0;
     }
@@ -2019,6 +2030,7 @@ find_efi_memmap(loader_ctx *lctx, uint32
     *descr_size = efi_mmap->descr_size;
     *descr_vers = efi_mmap->descr_vers;
     *mmap_size = efi_mmap->size - sizeof(struct mb2_tag_efi_mmap);
+    printk(TBOOT_ERR"AXA find_efi_memmap 3 descr_size %x mmap_size %x\n", *descr_size, *mmap_size);
     if (*mmap_size % *descr_size) {
         printk(TBOOT_WARN "EFI memmmap (0x%x) should be a multiple of descriptor size (0x%x)\n",
 	       *mmap_size, *descr_size);
Index: tboot-1.9.12/tboot/common/linux.c
===================================================================
--- tboot-1.9.12.orig/tboot/common/linux.c
+++ tboot-1.9.12/tboot/common/linux.c
@@ -145,7 +145,7 @@ bool expand_linux_image(const void *linu
     if ( hdr->header != HDRS_MAGIC ) {
         /* old kernel */
         printk(TBOOT_ERR
-               "Error: Old kernel (< 2.6.20) is not supported by tboot.\n");
+               "Error: Old kernel (< 2.6.20) is not supported by tboot.AXA %016Lx\n", (unsigned long long)hdr->header);
         return false;
     }
 
